// Code generated by MockGen. DO NOT EDIT.
// Source: rmq.go

// Package rmq is a generated GoMock package.
package rmq

import (
	gomock "github.com/golang/mock/gomock"
	amqp "github.com/streadway/amqp"
	excp "gitlab.fbs-d.com/dev/go/legacy/exceptions"
	reflect "reflect"
)

// MockIRmq is a mock of IRmq interface
type MockIRmq struct {
	ctrl     *gomock.Controller
	recorder *MockIRmqMockRecorder
}

// MockIRmqMockRecorder is the mock recorder for MockIRmq
type MockIRmqMockRecorder struct {
	mock *MockIRmq
}

// NewMockIRmq creates a new mock instance
func NewMockIRmq(ctrl *gomock.Controller) *MockIRmq {
	mock := &MockIRmq{ctrl: ctrl}
	mock.recorder = &MockIRmqMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIRmq) EXPECT() *MockIRmqMockRecorder {
	return m.recorder
}

// Connect mocks base method
func (m *MockIRmq) Connect() excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Connect")
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// Connect indicates an expected call of Connect
func (mr *MockIRmqMockRecorder) Connect() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Connect", reflect.TypeOf((*MockIRmq)(nil).Connect))
}

// IsClosed mocks base method
func (m *MockIRmq) IsClosed() bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsClosed")
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsClosed indicates an expected call of IsClosed
func (mr *MockIRmqMockRecorder) IsClosed() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsClosed", reflect.TypeOf((*MockIRmq)(nil).IsClosed))
}

// Channel mocks base method
func (m *MockIRmq) Channel() (IChannel, excp.IException) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Channel")
	ret0, _ := ret[0].(IChannel)
	ret1, _ := ret[1].(excp.IException)
	return ret0, ret1
}

// Channel indicates an expected call of Channel
func (mr *MockIRmqMockRecorder) Channel() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Channel", reflect.TypeOf((*MockIRmq)(nil).Channel))
}

// ExchangeDeclare mocks base method
func (m *MockIRmq) ExchangeDeclare(exchangeName, exchangeType string) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExchangeDeclare", exchangeName, exchangeType)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// ExchangeDeclare indicates an expected call of ExchangeDeclare
func (mr *MockIRmqMockRecorder) ExchangeDeclare(exchangeName, exchangeType interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExchangeDeclare", reflect.TypeOf((*MockIRmq)(nil).ExchangeDeclare), exchangeName, exchangeType)
}

// Rpc mocks base method
func (m *MockIRmq) Rpc(queueName, uuid string, body []byte) ([]byte, excp.IException) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Rpc", queueName, uuid, body)
	ret0, _ := ret[0].([]byte)
	ret1, _ := ret[1].(excp.IException)
	return ret0, ret1
}

// Rpc indicates an expected call of Rpc
func (mr *MockIRmqMockRecorder) Rpc(queueName, uuid, body interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Rpc", reflect.TypeOf((*MockIRmq)(nil).Rpc), queueName, uuid, body)
}

// ConsumeRpc mocks base method
func (m *MockIRmq) ConsumeRpc(queueName string, worker RpcWorkerFunc) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConsumeRpc", queueName, worker)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// ConsumeRpc indicates an expected call of ConsumeRpc
func (mr *MockIRmqMockRecorder) ConsumeRpc(queueName, worker interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConsumeRpc", reflect.TypeOf((*MockIRmq)(nil).ConsumeRpc), queueName, worker)
}

// Consume mocks base method
func (m *MockIRmq) Consume(queueName string, worker WorkerFunc) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Consume", queueName, worker)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// Consume indicates an expected call of Consume
func (mr *MockIRmqMockRecorder) Consume(queueName, worker interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Consume", reflect.TypeOf((*MockIRmq)(nil).Consume), queueName, worker)
}

// NonDurableConsume mocks base method
func (m *MockIRmq) NonDurableConsume(queueName string, worker WorkerFunc) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NonDurableConsume", queueName, worker)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// NonDurableConsume indicates an expected call of NonDurableConsume
func (mr *MockIRmqMockRecorder) NonDurableConsume(queueName, worker interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NonDurableConsume", reflect.TypeOf((*MockIRmq)(nil).NonDurableConsume), queueName, worker)
}

// Unconsume mocks base method
func (m *MockIRmq) Unconsume(queueName string) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unconsume", queueName)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// Unconsume indicates an expected call of Unconsume
func (mr *MockIRmqMockRecorder) Unconsume(queueName interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unconsume", reflect.TypeOf((*MockIRmq)(nil).Unconsume), queueName)
}

// Publish mocks base method
func (m *MockIRmq) Publish(queueName string, body []byte, headers amqp.Table) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", queueName, body, headers)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockIRmqMockRecorder) Publish(queueName, body, headers interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockIRmq)(nil).Publish), queueName, body, headers)
}

// ConsumeDelayed mocks base method
func (m *MockIRmq) ConsumeDelayed(exchange, queueName string, durable bool, worker WorkerFunc) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ConsumeDelayed", exchange, queueName, durable, worker)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// ConsumeDelayed indicates an expected call of ConsumeDelayed
func (mr *MockIRmqMockRecorder) ConsumeDelayed(exchange, queueName, durable, worker interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ConsumeDelayed", reflect.TypeOf((*MockIRmq)(nil).ConsumeDelayed), exchange, queueName, durable, worker)
}

// PublishDelayed mocks base method
func (m *MockIRmq) PublishDelayed(exchange, key string, durable bool, body []byte, headers amqp.Table) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "PublishDelayed", exchange, key, durable, body, headers)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// PublishDelayed indicates an expected call of PublishDelayed
func (mr *MockIRmqMockRecorder) PublishDelayed(exchange, key, durable, body, headers interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "PublishDelayed", reflect.TypeOf((*MockIRmq)(nil).PublishDelayed), exchange, key, durable, body, headers)
}

// ExchangePublish mocks base method
func (m *MockIRmq) ExchangePublish(exchangeName, exchangeType, routingKey string, data []byte) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExchangePublish", exchangeName, exchangeType, routingKey, data)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// ExchangePublish indicates an expected call of ExchangePublish
func (mr *MockIRmqMockRecorder) ExchangePublish(exchangeName, exchangeType, routingKey, data interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExchangePublish", reflect.TypeOf((*MockIRmq)(nil).ExchangePublish), exchangeName, exchangeType, routingKey, data)
}

// QueueBind mocks base method
func (m *MockIRmq) QueueBind(name, key, exchange string, noWait bool, args amqp.Table) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueBind", name, key, exchange, noWait, args)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// QueueBind indicates an expected call of QueueBind
func (mr *MockIRmqMockRecorder) QueueBind(name, key, exchange, noWait, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueBind", reflect.TypeOf((*MockIRmq)(nil).QueueBind), name, key, exchange, noWait, args)
}

// NonDurableQueueBind mocks base method
func (m *MockIRmq) NonDurableQueueBind(name, key, exchange string, noWait bool, args amqp.Table) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NonDurableQueueBind", name, key, exchange, noWait, args)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// NonDurableQueueBind indicates an expected call of NonDurableQueueBind
func (mr *MockIRmqMockRecorder) NonDurableQueueBind(name, key, exchange, noWait, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NonDurableQueueBind", reflect.TypeOf((*MockIRmq)(nil).NonDurableQueueBind), name, key, exchange, noWait, args)
}

// QueueUnbind mocks base method
func (m *MockIRmq) QueueUnbind(name, key, exchange string, args amqp.Table) excp.IException {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueUnbind", name, key, exchange, args)
	ret0, _ := ret[0].(excp.IException)
	return ret0
}

// QueueUnbind indicates an expected call of QueueUnbind
func (mr *MockIRmqMockRecorder) QueueUnbind(name, key, exchange, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueUnbind", reflect.TypeOf((*MockIRmq)(nil).QueueUnbind), name, key, exchange, args)
}

// QueueDelete mocks base method
func (m *MockIRmq) QueueDelete(name string, ifUnused, ifEmpty, noWait bool) (int, excp.IException) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueDelete", name, ifUnused, ifEmpty, noWait)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(excp.IException)
	return ret0, ret1
}

// QueueDelete indicates an expected call of QueueDelete
func (mr *MockIRmqMockRecorder) QueueDelete(name, ifUnused, ifEmpty, noWait interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueDelete", reflect.TypeOf((*MockIRmq)(nil).QueueDelete), name, ifUnused, ifEmpty, noWait)
}

// AddTrimmedFieldForLog mocks base method
func (m *MockIRmq) AddTrimmedFieldForLog(field string) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "AddTrimmedFieldForLog", field)
}

// AddTrimmedFieldForLog indicates an expected call of AddTrimmedFieldForLog
func (mr *MockIRmqMockRecorder) AddTrimmedFieldForLog(field interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "AddTrimmedFieldForLog", reflect.TypeOf((*MockIRmq)(nil).AddTrimmedFieldForLog), field)
}

// TrimFieldsForLog mocks base method
func (m *MockIRmq) TrimFieldsForLog(content []byte) []byte {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TrimFieldsForLog", content)
	ret0, _ := ret[0].([]byte)
	return ret0
}

// TrimFieldsForLog indicates an expected call of TrimFieldsForLog
func (mr *MockIRmqMockRecorder) TrimFieldsForLog(content interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TrimFieldsForLog", reflect.TypeOf((*MockIRmq)(nil).TrimFieldsForLog), content)
}

// MockIChannel is a mock of IChannel interface
type MockIChannel struct {
	ctrl     *gomock.Controller
	recorder *MockIChannelMockRecorder
}

// MockIChannelMockRecorder is the mock recorder for MockIChannel
type MockIChannelMockRecorder struct {
	mock *MockIChannel
}

// NewMockIChannel creates a new mock instance
func NewMockIChannel(ctrl *gomock.Controller) *MockIChannel {
	mock := &MockIChannel{ctrl: ctrl}
	mock.recorder = &MockIChannelMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockIChannel) EXPECT() *MockIChannelMockRecorder {
	return m.recorder
}

// ExchangeDeclare mocks base method
func (m *MockIChannel) ExchangeDeclare(name, kind string, durable, autoDelete, internal, noWait bool, args amqp.Table) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ExchangeDeclare", name, kind, durable, autoDelete, internal, noWait, args)
	ret0, _ := ret[0].(error)
	return ret0
}

// ExchangeDeclare indicates an expected call of ExchangeDeclare
func (mr *MockIChannelMockRecorder) ExchangeDeclare(name, kind, durable, autoDelete, internal, noWait, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ExchangeDeclare", reflect.TypeOf((*MockIChannel)(nil).ExchangeDeclare), name, kind, durable, autoDelete, internal, noWait, args)
}

// QueueDeclare mocks base method
func (m *MockIChannel) QueueDeclare(name string, durable, autoDelete, exclusive, noWait bool, args amqp.Table) (amqp.Queue, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueDeclare", name, durable, autoDelete, exclusive, noWait, args)
	ret0, _ := ret[0].(amqp.Queue)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueueDeclare indicates an expected call of QueueDeclare
func (mr *MockIChannelMockRecorder) QueueDeclare(name, durable, autoDelete, exclusive, noWait, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueDeclare", reflect.TypeOf((*MockIChannel)(nil).QueueDeclare), name, durable, autoDelete, exclusive, noWait, args)
}

// QueueBind mocks base method
func (m *MockIChannel) QueueBind(name, key, exchange string, noWait bool, args amqp.Table) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueBind", name, key, exchange, noWait, args)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueueBind indicates an expected call of QueueBind
func (mr *MockIChannelMockRecorder) QueueBind(name, key, exchange, noWait, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueBind", reflect.TypeOf((*MockIChannel)(nil).QueueBind), name, key, exchange, noWait, args)
}

// QueueUnbind mocks base method
func (m *MockIChannel) QueueUnbind(name, key, exchange string, args amqp.Table) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueUnbind", name, key, exchange, args)
	ret0, _ := ret[0].(error)
	return ret0
}

// QueueUnbind indicates an expected call of QueueUnbind
func (mr *MockIChannelMockRecorder) QueueUnbind(name, key, exchange, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueUnbind", reflect.TypeOf((*MockIChannel)(nil).QueueUnbind), name, key, exchange, args)
}

// QueueDelete mocks base method
func (m *MockIChannel) QueueDelete(name string, ifUnused, ifEmpty, noWait bool) (int, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "QueueDelete", name, ifUnused, ifEmpty, noWait)
	ret0, _ := ret[0].(int)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// QueueDelete indicates an expected call of QueueDelete
func (mr *MockIChannelMockRecorder) QueueDelete(name, ifUnused, ifEmpty, noWait interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "QueueDelete", reflect.TypeOf((*MockIChannel)(nil).QueueDelete), name, ifUnused, ifEmpty, noWait)
}

// Consume mocks base method
func (m *MockIChannel) Consume(queue, consumer string, autoAck, exclusive, noLocal, noWait bool, args amqp.Table) (<-chan amqp.Delivery, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Consume", queue, consumer, autoAck, exclusive, noLocal, noWait, args)
	ret0, _ := ret[0].(<-chan amqp.Delivery)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Consume indicates an expected call of Consume
func (mr *MockIChannelMockRecorder) Consume(queue, consumer, autoAck, exclusive, noLocal, noWait, args interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Consume", reflect.TypeOf((*MockIChannel)(nil).Consume), queue, consumer, autoAck, exclusive, noLocal, noWait, args)
}

// Publish mocks base method
func (m *MockIChannel) Publish(exchange, key string, mandatory, immediate bool, msg amqp.Publishing) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Publish", exchange, key, mandatory, immediate, msg)
	ret0, _ := ret[0].(error)
	return ret0
}

// Publish indicates an expected call of Publish
func (mr *MockIChannelMockRecorder) Publish(exchange, key, mandatory, immediate, msg interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Publish", reflect.TypeOf((*MockIChannel)(nil).Publish), exchange, key, mandatory, immediate, msg)
}

// NotifyReturn mocks base method
func (m *MockIChannel) NotifyReturn(ch chan amqp.Return) chan amqp.Return {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "NotifyReturn", ch)
	ret0, _ := ret[0].(chan amqp.Return)
	return ret0
}

// NotifyReturn indicates an expected call of NotifyReturn
func (mr *MockIChannelMockRecorder) NotifyReturn(ch interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "NotifyReturn", reflect.TypeOf((*MockIChannel)(nil).NotifyReturn), ch)
}

// Close mocks base method
func (m *MockIChannel) Close() error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Close")
	ret0, _ := ret[0].(error)
	return ret0
}

// Close indicates an expected call of Close
func (mr *MockIChannelMockRecorder) Close() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Close", reflect.TypeOf((*MockIChannel)(nil).Close))
}

// Qos mocks base method
func (m *MockIChannel) Qos(prefetchCount, prefetchSize int, global bool) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Qos", prefetchCount, prefetchSize, global)
	ret0, _ := ret[0].(error)
	return ret0
}

// Qos indicates an expected call of Qos
func (mr *MockIChannelMockRecorder) Qos(prefetchCount, prefetchSize, global interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Qos", reflect.TypeOf((*MockIChannel)(nil).Qos), prefetchCount, prefetchSize, global)
}
